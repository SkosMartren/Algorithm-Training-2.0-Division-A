- Алгоритм решения  
Положим, что караван положил перед шахом ряд драгоценных камней, который отождествляется с S. 
для каждого камня из S найдем индекс его вхождения == отобразим для каждого камня из S в вектор его индекс. Очевидно, элементы в векторе индексов будут упорядочены.
Теперь, для каждой пары красивых камней (a_q, b_q), проитерируемся по каждому индексу a_q = S[i_1] = ... = S[i_x], то есть проитерируемся по вектору, который содержит
{i_1, ..., i_x} -- его можно получить с помощью ранее созданного отображения по ключу a_q.

Теперь рассмотрим b_q = S[j_1] = ... = S[j_y]. Индексы {j_1, ..., j_y} можно получить  с помощью ранее созданного отображения по ключу b_q

Для каждого i_t : i_1 <= i_t <= i_x будем искать такой j_s : j_1 <= j_s <= j_y, что i_t < j_s. Реализуем это с  помощью бинарного поиска, а именно алгоритма upper_bound.

Далее надо подсчитать количетсво таких j_s и записать в ответ.

Повторить операцию k раз для каждой пары красивых камней. 
